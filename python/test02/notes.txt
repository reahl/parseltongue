6	PyObject_HEAD

	    This is a macro which expands to the declarations of the fields of the PyObject type; it is used when declaring new types which represent objects without a varying length. The specific fields it expands to depend on the definition of Py_TRACE_REFS. By default, that macro is not defined, and PyObject_HEAD expands to:

	    Py_ssize_t ob_refcnt;
	    PyTypeObject *ob_type;

	    When Py_TRACE_REFS is defined, it expands to:

	    PyObject *_ob_next, *_ob_prev;
	    Py_ssize_t ob_refcnt;
	    PyTypeObject *ob_type;

__________________________________________________________________________________________________

18	Py_TYPE(self)->tp_free((PyObject*)self)


	Py_TYPE(o)

	    This macro is used to access the ob_type member of a Python object. It expands to:

	    (((PyObject*)(o))->ob_type)

__________________________________________________________________________________________________

30	allocfunc PyTypeObject.tp_alloc

	    An optional pointer to an instance allocation function.

	    The function signature is

	    PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems)

	    The purpose of this function is to separate memory allocation from memory initialization. It should return a pointer to a block of memory of adequate length for the instance, suitably aligned, and initialized to zeros, but with ob_refcnt set to 1 and ob_type set to the type argument. If the type’s tp_itemsize is non-zero, the object’s ob_size field should be initialized to nitems and the length of the allocated memory block should be tp_basicsize + nitems*tp_itemsize, rounded up to a multiple of sizeof(void*); otherwise, nitems is not used and the length of the block should be tp_basicsize.

	    Do not use this function to do any other instance initialization, not even to allocate additional memory; that should be done by tp_new.

	    This field is inherited by static subtypes, but not by dynamic subtypes (subtypes created by a class statement); in the latter, this field is always set to PyType_GenericAlloc(), to force a standard heap allocation strategy. That is also the recommended value for statically defined types.

__________________________________________________________________________________________________

159	Getseters

	The getter function is passed a Noddy object and a “closure”, which is void pointer. In this case, the closure is ignored. (The closure supports an advanced usage in which definition data is passed to the getter and setter. This could, for example, be used to allow a single set of getter and setter functions that decide the attribute to get or set based on data in the closure.)

	The setter function is passed the Noddy object, the new value, and the closure. The new value may be NULL, in which case the attribute is being deleted. In our setter, we raise an error if the attribute is deleted or if the attribute value is not a string.

Why increase ref count in getter??

__________________________________________________________________________________________________

260	struct PyGetSetDef* PyTypeObject.tp_getset

	    An optional pointer to a static NULL-terminated array of PyGetSetDef structures, declaring computed attributes of instances of this type.

	    For each entry in the array, an entry is added to the type’s dictionary (see tp_dict below) containing a getset descriptor.

	    This field is not inherited by subtypes (computed attributes are inherited through a different mechanism).

	    Docs for PyGetSetDef:

	    typedef PyObject *(*getter)(PyObject *, void *);
	    typedef int (*setter)(PyObject *, PyObject *, void *);

	    typedef struct PyGetSetDef {
	        char *name;    /* attribute name */
	        getter get;    /* C function to get the attribute */
	        setter set;    /* C function to set or delete the attribute */
	        char *doc;     /* optional doc string */
	        void *closure; /* optional additional data for getter and setter */
	    } PyGetSetDef;

__________________________________________________________________________________________________

277	This is so important that we’re going to pick the top of it apart still further:

	PyVarObject_HEAD_INIT(NULL, 0)

	This line is a bit of a wart; what we’d like to write is:

	PyVarObject_HEAD_INIT(&PyType_Type, 0)

	as the type of a type object is “type”, but this isn’t strictly conforming C and some compilers complain. Fortunately, this member will be filled in for us by PyType_Ready().


PyVarObject_HEAD_INIT(type, size)

    This is a macro which expands to initialization values for a new PyVarObject type, including the ob_size field. This macro expands to:

    _PyObject_EXTRA_INIT
    1, type, size,

__________________________________________________________________________________________________

325	PyObject_HEAD_INIT(type)

	    This is a macro which expands to initialization values for a new PyObject type. This macro expands to:

	    _PyObject_EXTRA_INIT
	    1, type,

__________________________________________________________________________________________________

331	int PyType_Ready(PyTypeObject *type)

    	Finalize a type object. This should be called on all type objects to finish their initialization. This function is responsible for adding inherited slots from a type’s base class. Return 0 on success, or return -1 and sets an exception on error.
